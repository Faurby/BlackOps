@inject HttpClient Http

<Virtualize Context="message" ItemsProvider="LoadMessages">
    <MessageBox message=message></MessageBox>
</Virtualize>


@code {
    private Dictionary<int, Message> messageCacheNew;

    protected override async Task OnInitializedAsync()
    {
        messageCacheNew = new Dictionary<int, Message>();
    }

    private async ValueTask<ItemsProviderResult<Message>> LoadMessages(ItemsProviderRequest request)
    {
        //System.Console.WriteLine("start index: " + request.StartIndex + " - count: " + request.Count);

        // Make sure all requested items exist in cache
        for (int i = request.StartIndex; i < request.StartIndex + request.Count; i++)
        {
            if (!messageCacheNew.ContainsKey(i))
            {
                //System.Console.WriteLine("cache did not contain all items, fetching from database");

                // If key is not contained in cache, request from database
                var virtualizeResult = await Http.GetFromJsonAsync<VirtualizedResponse<Message>>("api/Messages/virtualized/" +
                request.StartIndex + "&" + request.Count);

                // Add retrieved items to cache
                for (int j = 0; j < virtualizeResult.Items.Count; j++)
                {
                    int newKey = request.StartIndex + j;
                    //System.Console.WriteLine("adding key: " + newKey);

                    if (!messageCacheNew.ContainsKey(newKey))
                    {
                        //System.Console.WriteLine("key already existed: " + newKey);
                        messageCacheNew.Add(newKey, virtualizeResult.Items[j]);
                    }
                }
                return new ItemsProviderResult<Message>(virtualizeResult!.Items, virtualizeResult!.Size); ;
            }
        }

        //System.Console.WriteLine("Items exist in cache!");

        // Once we are sure the messages exists in cache we can return from cache
        List<Message> messagesFromCache =
        messageCacheNew.Keys
        .Where(key => (request.StartIndex < key && key < request.StartIndex + request.Count))
        .Select(k => messageCacheNew[k]).ToList();

        return new ItemsProviderResult<Message>(messagesFromCache, messageCacheNew.Count + 5); ;
    }

}